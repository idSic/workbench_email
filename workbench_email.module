<?php
/**
 * @file
 * Code for the Workbench Email Module.
 */
define('WORKBENCH_EMAIL_AUTHOR', -1);

include_once 'workbench_email.forms.inc';

/**
 * Implements hook_menu().
 */
function workbench_email_menu() {
  $items = array();

  // Module settings.
  $items["admin/config/workbench/email"] = array(
    'title' => 'Workbench Email',
    'description' => 'Configure email moderation notification.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_email_form'),
    'access arguments' => array('administer workbench emails'),
    'file' => 'workbench_email.admin.inc',
  );

  return $items;
}

/**
 * Implments hook_module_implements_alter().
 *
 * Make sure workbench_email form_alter fires after workbench_moderation
 * form_alter.
 */
function workbench_email_module_implements_alter(&$implementations, $hook) {
  if (strpos($hook, 'form') !== FALSE) {
    if (isset($implementations['workbench_moderation'], $implementations['workbench_email'])) {
      $workbench_email = $implementations['workbench_email'];
      unset($implementations['workbench_email']);

      $workbench_moderation = $implementations['workbench_moderation'];
      unset($implementations['workbench_moderation']);

      $implementations['workbench_moderation'] = $workbench_moderation;
      $implementations['workbench_email'] = $workbench_email;
    }
  }
}

/**
 * Implements hook_theme().
 */
function workbench_email_theme() {
  return array(
    'workbench_email_form' => array(
      'file' => 'workbench_email.admin.inc',
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_help().
 */
function workbench_email_help($path, $arg) {
  switch ($path) {
    case 'admin/config/workbench/moderation/email-transitions':
      return '<p>' . t("The Workbench Moderation Email module keeps track of
                       when a node moves from one state to another. This admin
                       page can help you manage who gets emailed when those
                       transitions happen.") . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function workbench_email_permission() {
  $permissions = array();
  $permissions['administer workbench emails'] = array(
    'title' => t('Administer Workbench Emails'),
    'description' => t('Perform administration tasks
                       related to Workbench Emails.'),
  );
  return $permissions;
}

/**
 * Implements hook_features_api().
 */
function workbench_email_features_api() {
  return array(
    'workbench_email' => array(
      'name' => t('Workbench Email'),
      'default_hook' => 'workbench_email_export',
      'feature_source' => TRUE,
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'file' => drupal_get_path('module', 'workbench_email') . '/workbench_email.features.inc',
    ),
  );
}

/**
 * Determines the emails attributes.
 *
 * Sets the emails subject / message and sends the email.
 *
 * @param string $email
 *   The send to email address
 *
 * @param object $email_transition
 *   The email transition used for determining the subject / message
 *   to retrieve
 *
 * @param object $node
 *   The node returned from node_save
 */
function workbench_email_mail_send($email, $email_transition, $node) {
  $module = 'workbench_email';
  $key = 'workflow_email';

  $to = $email;
  $from = variable_get('site_mail', 'admin@example.com');

  if (empty($email_transition->subject) && empty($email_transition->message)) {
    drupal_set_message(t('No email template is set, so no email was sent.
                       Contact your system admin to resolve this issue.'));
    return;
  }

  global $user;
  $params['subject'] = $email_transition->subject;
  $params['message'] = $email_transition->message;
  $params['node'] = $node;
  $params['user'] = $user;
  $language = language_default();
  $send = TRUE;
  $result = drupal_mail($module, $key, $to, $language, $params, $from, $send);
  if ($result['result'] == TRUE) {
    drupal_set_message(t('Your message has been sent.'));
  }
  else {
    drupal_set_message(t('There was a problem sending your
                         message and it was not sent.'), 'error');
  }
}

/**
 * Implements hook_mail().
 */
function workbench_email_mail($key, &$message, $params) {
  switch ($key) {
    case 'workflow_email':
      $message['subject'] = t(token_replace($params['subject'], $params));
      $message['body'][] = t(token_replace($params['message'], $params));
      break;
  }
}

/**
 * Retrieves only the moderation permission tasks.
 *
 * @return permission
 *  Returns the permissions for moderating content
 */
function workbench_email_determine_moderation_permissions() {
  // Per-node-type, per-transition permissions.
  // Used by workbench_moderation_state_allowed().
  $permissions = array();
  $node_types = workbench_moderation_moderate_node_types();
  $transitions = workbench_moderation_transitions();

  foreach ($transitions as $transition) {
    $from_state = $transition->from_name;
    $to_state = $transition->to_name;

    // Always set a permission to perform all moderation states.
    $permissions["moderate content from $from_state to $to_state"] = TRUE;

    // Per-node type permissions are very complex, and should only be used if
    // absolutely needed. For right now, this is hardcoded to OFF. To enable it,
    // Add this line to settings.php and then reset permissions.
    //   $conf['workbench_moderation_per_node_type'] = TRUE;
    if (variable_get('workbench_moderation_per_node_type', FALSE)) {
      foreach ($node_types as $node_type) {
        $permissions["moderate $node_type state from $from_state to $to_state"] = TRUE;
      }
    }
  }
  return $permissions;
}

/**
 * Determines the valid roles for a given moderation task and content type(s).
 *
 * @return valid_roles
 *   Returns the valid roles or an empty array
 */
function workbench_email_determine_valid_roles() {
  $valid_roles = array();
  $valid_roles[0] = 'author';
  $types = drupal_map_assoc(workbench_moderation_moderate_node_types());
  $all_types = node_type_get_types();
  foreach ($types as $type) {
    $types[$type] = $all_types[$type]->name;
  }

  $moderation_permissions = workbench_email_determine_moderation_permissions();
  $roles = user_roles();
  foreach ($roles AS $rid => $role) {
    // Get a full list of this role's permissions.
    $actual_permissions_set = user_role_permissions(array_filter(array(
      $rid => TRUE,
      DRUPAL_AUTHENTICATED_RID => ($rid != DRUPAL_ANONYMOUS_RID),
    )));

    $valid_permissions = array();
    foreach ($actual_permissions_set AS $role_rid => $actual_permissions) {
      foreach ($actual_permissions AS $permission => $value) {
        if (array_key_exists($permission, $moderation_permissions)) {
          $valid_permissions[] = $permission;
        }
      }
    }

    if ($valid_permissions) {
      $valid_roles[$rid] = $role;
    }
  }
  return $valid_roles;
}

/**
 * Determines the valid roles for a given transition.
 *
 * @param string $from_state
 *   The transition from_state
 *
 * @param string $to_state
 *   The transition to_state
 *
 * @param string $node_type
 *   The node type used to determine valid roles.
 *
 * @return valid_roles
 *   Returns the valid roles or an empty array
 */
function workbench_email_determine_valid_roles_per_transition($from_state, $to_state, $node_type = NULL) {
  $roles = user_roles();
  $valid_roles = array();
  if ($node_type == NULL) {
    $transition = "moderate content from " . $from_state . " to " . $to_state;
  }

  foreach ($roles as $rid => $role) {
    if ($role == "administrator") {
      continue;
    }
    // Get a full list of this role's permissions.
    $actual_permissions = user_role_permissions(array_filter(array(
      $rid => TRUE,
      DRUPAL_AUTHENTICATED_RID => ($rid != DRUPAL_ANONYMOUS_RID),
    )));

    foreach ($actual_permissions as $permissions) {
      if (isset($permissions[$transition])) {
        $valid_roles[$rid] = $role;
      }
    }
  }
  return $valid_roles;
}

/**
 * Determines the email attributes to retrieve.
 *
 * @param object $transition
 *   The transtion object
 *
 * @param int $rid
 *   The role ID
 *
 * @return email
 *   Returns the workbench_email object or FALSE
 */
function workbench_email_get($transition = NULL, $rid = NULL, $author = FALSE, $automatic = FALSE) {
  $emails = array();
  $query = db_select('workbench_emails', 'wve')
    ->fields('wve', array('rid', 'from_name', 'to_name', 'subject', 'message', 'author', 'automatic'));
  if ($transition) {
    $query->condition('wve.from_name', $transition->from_name);
    $query->condition('wve.to_name', $transition->to_name);
  }
  if ($rid) {
    $query->condition('wve.rid', $rid);
  }
  if ($author) {
    $query->condition('wve.author', $author);
  }
  if ($automatic) {
    $query->condition('wve.automatic', $automatic);
  }
  $result = $query->execute();
  foreach ($result as $row) {
    $emails[$row->from_name . '_to_' . $row->to_name][$row->rid] = $row;
  }
  return $emails;
}

/**
 * Saves the email into the table.
 *
 * @param object $transition
 *   The transtion object
 *
 * @param int $rid
 *   The role ID
 *
 * @param string $subject
 *   The email subject to save
 *
 * @param string $message
 *   The email message to save
 *
 * @return db_merge
 *   Returns the TRUE or FALSE
 */
function workbench_email_save($transition, $rid, $subject = NULL, $message = NULL, $author = FALSE, $automatic = FALSE) {
  $query = db_merge('workbench_emails');
  $query->key(
    array(
      'from_name' => $transition->from_name,
      'to_name' => $transition->to_name,
      'rid' => $rid,
    )
  );

  $query->fields(
    array(
      'from_name' => $transition->from_name,
      'to_name' => $transition->to_name,
      'rid' => $rid,
    )
  );

  if ($subject) {
    $query->fields(array('subject' => $subject));
  }
  if ($message) {
    $query->fields(array('message' => $message));
  }
  if ($author) {
    $query->fields(array('author' => $author));
  }
  if ($automatic) {
    $query->fields(array('automatic' => $automatic));
  }

  $query->execute();
}

/**
 * Deletes the email from the table.
 *
 * @param object $transition
 *   The transition object
 *
 * @param int $rid
 *   The role ID
 *
 * @return db_delete
 *   Returns TRUE or FALSE
 */
function workbench_email_delete($transition, $rid) {
  db_delete('workbench_emails')
    ->condition('from_name', $transition->from_name)
    ->condition('to_name', $transition->to_name)
    ->condition('rid', $rid)
    ->execute();
}

/**
 * Deletes all emails from the table
 *
 * @return db_delete
 *   Returns TRUE or FALSE
 */
function workbench_email_delete_all() {
  db_delete('workbench_emails')->execute();
}

/**
 * Returns user array if they have a certain role.
 *
 * @param int $rid
 *   The role ID
 *
 * @return users
 *   Returns an array of users or an empty array
 */
function workbench_email_get_users($rid) {
  $uids = array();
  $query = db_select('users_roles', 'ur')
    ->fields('ur', array('uid'))
    ->condition('ur.rid', $rid);
  $query->distinct();
  $result = $query->execute();
  foreach ($result as $row) {
    $uids[] = $row->uid;
  }
  $users = array();
  $users = user_load_multiple($uids);
  return $users;
}
